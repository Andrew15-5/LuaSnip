local ast_utils = require("luasnip.util.parser.ast_utils")
local tNode = require("luasnip.nodes.textNode")
local iNode = require("luasnip.nodes.insertNode")
local fNode = require("luasnip.nodes.functionNode")
local cNode = require("luasnip.nodes.choiceNode")
local dNode = require("luasnip.nodes.dynamicNode")
local sNode = require("luasnip.nodes.snippet")
local functions = require("luasnip.util.functions")
local Environ = require("luasnip.util.environ")

local M = {}

local _split = function(s)
	return vim.split(s, "\n", { plain = true })
end

local _to_node

-- these actually create nodes from any AST.
local to_node_funcs = {
	-- careful! this only returns a list of nodes, not a full snippet!
	-- The table can be passed to the regular snippet-constructors.
	[ast_utils.types.SNIPPET] = function(ast, tabstops)
		local children = {}
		for i, child in ipairs(ast.children) do
			children[i] = _to_node(child, tabstops)
		end

		return children
	end,
	[ast_utils.types.TEXT] = function(ast, state)
		local text = _split(ast.esc)
		-- store text for `VARIABLE`, might be needed for indentation.
		state.last_text = text
		return tNode.T(text)
	end,
	[ast_utils.types.CHOICE] = function(ast)
		local choices = {}
		for i, choice in ipairs(ast.items) do
			choices[i] = tNode.T(_split(choice))
		end

		return cNode.C(ast.tabstop, choices)
	end,
	[ast_utils.types.TABSTOP] = function(ast, state)
		local existing_tabstop = state.tabstops[ast.tabstop]
		if existing_tabstop then
			-- this tabstop is a mirror of an already-parsed tabstop/placeholder.
			return fNode.F(functions.copy, { existing_tabstop })
		end

		-- tabstops don't have placeholder-text.
		local node = iNode.I(ast.tabstop)
		state.tabstops[ast.tabstop] = node

		return node
	end,
	[ast_utils.types.VARIABLE] = function(ast, state)
		local var = ast.name
		if Environ.is_valid_var(var) then
			-- pass varname as first user_arg.
			local f = fNode.F(functions.better_var, {}, { user_args = { var } })

			-- if the variable is preceded by \n<indent>, the indent is applied to
			-- all lines of the variable (important for eg. TM_SELECTED_TEXT).
			if state.last_text ~= nil and #state.last_text > 1 then
				local last_line_indent =
					state.last_text[#state.last_text]:match(
						"^%s+$"
					)
				local indentstring = var ~= "TM_SELECTED_TEXT"
						and "$PARENT_INDENT" .. last_line_indent
					or last_line_indent

				if last_line_indent then
					return sNode.ISN(nil, { f }, indentstring)
				end
			end
		end
		-- if the variable is unknown, just insert an empty text-snippet.
		-- maybe put this into `state.last_text`? otoh, this won't be visible.
		-- Don't for now.
		return tNode.T({ "" })
	end,
}

--- Converts any ast into usable nodes.
--- Snippets return a table of nodes, those can be used like `fmt`.
---@param ast table: AST, as generated by `require("vim.lsp._snippet").parse`
---@param state table:
--- - `tabstops`: maps tabstop-position to already-parsed tabstops.
--- - `last_text`: stores last text, VARIABLE might have to be indented with
---   its contents (`"\n\t$SOMEVAR"`, all lines of $SOMEVAR have to be indented
---   with "\n").
--- This should most likely be `{}`.
---@return table: node corresponding to `ast`.
function _to_node(ast, state)
	local l = to_node_funcs[ast.type](ast, state)
	return l
end

function M.to_node(ast)
	return _to_node(ast, { tabstops = {}, last_text = nil })
end

return M
