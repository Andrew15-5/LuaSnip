local ast_utils = require("luasnip.util.parser.ast_utils")
local tNode = require("luasnip.nodes.textNode")
local iNode = require("luasnip.nodes.insertNode")
local fNode = require("luasnip.nodes.functionNode")
local cNode = require("luasnip.nodes.choiceNode")
local dNode = require("luasnip.nodes.dynamicNode")
local functions = require("luasnip.util.functions")

local M = {}

local _split = function(s)
	return vim.split(s, "\n", { plain = true })
end

-- these actually create nodes from any AST.
local to_node_funcs = {
	-- careful! this only returns a list of nodes, not a full snippet!
	-- The table can be passed to the regular snippet-constructors.
	[ast_utils.types.SNIPPET] = function(ast, tabstops)
		local children = {}
		for i, child in ipairs(ast.children) do
			children[i] = M.to_node(child, tabstops)
		end

		return children
	end,
	[ast_utils.types.TEXT] = function(ast)
		return tNode.T(_split(ast.esc))
	end,
	[ast_utils.types.CHOICE] = function(ast)
		local choices = {}
		for i, choice in ipairs(ast.items) do
			choices[i] = tNode.T(_split(choice))
		end

		return cNode.C(ast.tabstop, choices)
	end,
	[ast_utils.types.TABSTOP] = function(ast, tabstops)
		local existing_tabstop = tabstops[ast.tabstop]
		if existing_tabstop then
			-- this tabstop is a mirror of an already-parsed tabstop/placeholder.
			return fNode.F(functions.copy, { existing_tabstop })
		end

		-- tabstops don't have placeholder-text.
		local node = iNode.I(ast.tabstop)
		tabstops[ast.tabstop] = node

		return node
	end,
	end,
}

--- Converts any ast into usable nodes.
--- Snippets return a table of nodes, those can be used like `fmt`.
---@param ast table: AST, as generated by `require("vim.lsp._snippet").parse`
---@param tabstops table: maps tabstop-position to already-parsed tabstops.
--- This should most likely be `{}`.
---@return table: node corresponding to `ast`.
function M.to_node(ast, tabstops)
	local l = to_node_funcs[ast.type](ast, tabstops)
	return l
end

return M
